#!/usr/bin/env python3
"""
Heroes of History - Local Data Analyzer
Full rewrite using startup.json (HeroPush-based data model)
"""

import os
import re
import uuid
import json
import base64
import requests
from datetime import datetime
from getpass import getpass
import argparse


# ============================================================
#  CONSTANTS
# ============================================================

JSON_CONTENT_TYPE = "application/json"
PROTOBUF_CONTENT_TYPE = "application/x-protobuf"

GAME_LOGIN_URL = "https://{subdomain}.heroesgame.com/api/login"
ACCOUNT_PLAY_URL = "https://{subdomain}.heroesofhistorygame.com/core/api/account/play"
STARTUP_API_URL = "https://{world_id}.heroesofhistorygame.com/game/startup"

# ============================================================
#  CLASS DEF: HoHLocalAnalyzer
# ============================================================

class HoHLocalAnalyzer:
    def __init__(self, world_id='un1', data_dir='hoh_local_data'):
        self.world_id = world_id
        self.data_dir = data_dir
        self.session_data = None
        self.is_beta = world_id.startswith('zz')

        # Will be filled after parsing startup.json
        self.startup = None
        self.messages = []

        # Parsed data (filled in SECTION 3)
        self.player_info = {}
        self.heroes = []
        self.decks = []
        self.equipment = {}
        self.relics = {}
        self.cities = []
        self.alliance_members = []
        self.alliance_cities = []

    # ------------------------------------------------------------
    #  Load Metadata
    # ------------------------------------------------------------

    def load_metadata(self):
        """
        Loads metadata.json generated by metadata_extractor.py.
        Stores it in self.meta for all other methods to use.
        """
        meta_path = os.path.join(self.data_dir, "metadata.json")

        # If metadata.json is not in data_dir, also check the scripts folder
        if not os.path.exists(meta_path):
            alt_path = os.path.join(os.path.dirname(__file__), "metadata.json")
            if os.path.exists(alt_path):
                meta_path = alt_path

        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                self.meta = json.load(f)
            print(f"üìò Loaded metadata.json from: {meta_path}")
        except Exception as e:
            print("‚ö†Ô∏è Unable to load metadata.json:", e)
            self.meta = {}

    # ------------------------------------------------------------
    #  METADATA TRANSLATION UTILITIES (Plain English Labels)
    # ------------------------------------------------------------

    def _clean_id_label(self, raw):
        """
        Converts something like:
          'building.Building_Egypt_Home_Small_4'
        Into a more readable format:
          'Egypt Home Small 4'
        Used as a fallback when no metadata is available.
        """
        if not raw:
            return ""

        # Remove common prefixes
        parts = raw.replace("building.Building_", "") \
                   .replace("hero.", "") \
                   .replace("unit_stat.", "") \
                   .replace("equipment_rarity.", "") \
                   .replace("equipment_slot_type.", "") \
                   .replace("equipment_set.", "") \
                   .replace("_", " ")

        # Capitalize words
        parts = " ".join(w.capitalize() for w in parts.split())

        return parts

    # ------------------------------------------------------------
    #  STAT TRANSLATION
    # ------------------------------------------------------------

    def translate_stat(self, stat_id):
        """
        Converts raw stat identifiers into readable English names.
        Uses metadata if available; otherwise falls back to cleaned label.
        """

        if not stat_id:
            return ""

        # Check if stat definitions exist in metadata
        stat_meta = self.meta.get("stats", {})

        # Look up UnitStatDto or HeroUnitStatValueDefinitionDTO
        for key, fields in stat_meta.items():
            # fields: { "type": {...}, "value": {...}, ... }
            for f_name, f_def in fields.items():
                if f_def.get("type") == "string" and stat_id in f_def.get("options_raw", ""):
                    return f_name

        # Fallback: prettify
        return self._clean_id_label(stat_id)

    # ------------------------------------------------------------
    #  EQUIPMENT RARITY
    # ------------------------------------------------------------

    def translate_equipment_rarity(self, rarity_id):
        """
        Convert equipment_rarity.x into friendly labels using metadata.
        """
        if not rarity_id:
            return ""

        rarities = self.meta.get("equipment", {}).get("rarities", {})
        # Rarity enums typically look like EquipmentRarity or similar
        for enum_name, enum_data in rarities.items():
            for k, v in enum_data["values"].items():
                if str(v) in rarity_id or k in rarity_id:
                    # k = EquipmentRarity_LEGENDARY etc.
                    return k.replace("EquipmentRarity_", "").replace("_", " ").title()

        # fallback
        return self._clean_id_label(rarity_id)

    # ------------------------------------------------------------
    #  EQUIPMENT SLOT
    # ------------------------------------------------------------

    def translate_equipment_slot(self, slot_id):
        if not slot_id:
            return ""

        slots = self.meta.get("equipment", {}).get("slot_types", {})

        for enum_name, enum_data in slots.items():
            for k, v in enum_data["values"].items():
                if k in slot_id or str(v) in slot_id:
                    return k.replace("EquipmentSlotType_", "").replace("_", " ").title()

        return self._clean_id_label(slot_id)

    # ------------------------------------------------------------
    #  HERO NAME
    # ------------------------------------------------------------

    def translate_hero(self, hero_def_id):
        """
        hero.AlexanderTheGreat  -> Alexander The Great
        hero.JoanOfArc          -> Joan Of Arc
        """
        if not hero_def_id:
            return ""

        # Remove 'hero.' prefix if present
        if hero_def_id.startswith("hero."):
            hero_def_id = hero_def_id[5:]

        # Title-case: JoanOfArc -> "Joan Of Arc"
        name = []
        current = ""
        for char in hero_def_id:
            if char.isupper() and current:
                name.append(current)
                current = char
            else:
                current += char
        name.append(current)

        human_name = " ".join(w for w in name)
        return human_name

    # ------------------------------------------------------------
    #  BUILDING TRANSLATION (CATEGORY, SIZE, LEVEL, ERA)
    # ------------------------------------------------------------

    def translate_building(self, building_key):
        """
        Input:
            "building.Building_Egypt_Home_Small_4"
        Output:
            "Home (Small), Level 4 ‚Äì Egypt"
        """

        if not building_key:
            return ""

        raw = building_key.replace("building.Building_", "")
        parts = raw.split("_")

        if len(parts) < 4:
            return self._clean_id_label(building_key)

        era = parts[0]
        category = parts[1]
        size = parts[2]
        level = parts[3]

        era = era.replace("AgeOfTheFranks", "Age of the Franks") \
                 .replace("ClassicGreece", "Classic Greece") \
                 .replace("IberianEra", "Iberian Era") \
                 .replace("FeudalAge", "Feudal Age") \
                 .replace("BronzeAge", "Bronze Age") \
                 .replace("Egypt", "Egypt")

        category = category.replace("Home", "Home") \
                           .replace("Workshop", "Workshop") \
                           .replace("CultureSite", "Culture Site") \
                           .replace("Farm", "Farm") \
                           .replace("Special", "Special") \
                           .replace("Barracks", "Barracks")

        size = size.replace("Small", "Small") \
                   .replace("Average", "Average") \
                   .replace("Large", "Large") \
                   .replace("Compact", "Compact") \
                   .replace("Moderate", "Moderate") \
                   .replace("Little", "Little")

        return f"{category} ({size}), Level {level} ‚Äì {era}"

    # ------------------------------------------------------------
    #  BUILDING GROUPING ENGINE
    # ------------------------------------------------------------

    def _group_buildings(self, placed):
        """
        Groups building keys into:
           Category -> Size -> { count, levels }

        Example structure returned:
        {
            "Home": {
                "Small":  { "count": 8,  "levels": [4,3,1] },
                "Average":{ "count": 12, "levels": [4,2,1] },
            },
            "Workshop": {
                "Goldsmith": { "count": 2, "levels": [5,4] }
            }
        }
        """
        groups = {}

        for raw_key, amount in placed.items():
            raw = raw_key.replace("building.Building_", "")
            parts = raw.split("_")

            # Expected: Era, Category, Size, Level
            if len(parts) < 4:
                continue

            era = parts[0]
            category = parts[1]
            size = parts[2]
            level = int(parts[3])

            category_label = category \
                .replace("Home", "Home") \
                .replace("Workshop", "Workshop") \
                .replace("CultureSite", "Culture Site") \
                .replace("Farm", "Farm") \
                .replace("Special", "Special") \
                .replace("Barracks", "Barracks") \
                .replace("City", "City")

            # Initialize category
            if category_label not in groups:
                groups[category_label] = {}

            # Initialize size variant grouping
            size_label = size \
                .replace("Small", "Small") \
                .replace("Average", "Average") \
                .replace("Large", "Large") \
                .replace("Compact", "Compact") \
                .replace("Moderate", "Moderate") \
                .replace("Little", "Little")

            if size_label not in groups[category_label]:
                groups[category_label][size_label] = {
                    "count": 0,
                    "levels": []
                }

            groups[category_label][size_label]["count"] += amount
            groups[category_label][size_label]["levels"].append(level)

        # Sort levels for readability
        for cat in groups:
            for size in groups[cat]:
                groups[cat][size]["levels"].sort()

        return groups

    # ------------------------------------------------------------
    #  RELIC TRANSLATION
    # ------------------------------------------------------------

    def translate_relic(self, relic_def_id):
        """
        Improve relic labels if desired.
        """
        if not relic_def_id:
            return ""

        return self._clean_id_label(relic_def_id)
    
    # ------------------------------------------------------------
    #  Basic Headers
    # ------------------------------------------------------------

    def default_headers(self):
        return {"Content-Type": JSON_CONTENT_TYPE}

    def api_headers(self, accept_type=PROTOBUF_CONTENT_TYPE):
        if not self.session_data:
            raise Exception("Not logged in")

        return {
            "X-AUTH-TOKEN": self.session_data["sessionId"],
            "X-Request-Id": str(uuid.uuid4()),
            "X-Platform": "browser",
            "X-ClientVersion": self.session_data["clientVersion"],
            "Accept-Encoding": "gzip",
            "Content-Type": PROTOBUF_CONTENT_TYPE,
            "Accept": accept_type,
        }

    # ------------------------------------------------------------
    #  Directory Setup
    # ------------------------------------------------------------

    def setup_directories(self):
        """
        Safely clean all subfolders without deleting the top-level directory.
        This avoids Windows/OneDrive 'Access Denied' errors.
        """
        import shutil

        # Ensure top-level exists
        os.makedirs(self.data_dir, exist_ok=True)

        subfolders = ["raw", "parsed", "analysis", "csv_exports"]

        for sub in subfolders:
            full = os.path.join(self.data_dir, sub)

            # If subfolder exists, delete only its contents
            if os.path.exists(full):
                for entry in os.listdir(full):
                    path = os.path.join(full, entry)

                    try:
                        if os.path.isfile(path) or os.path.islink(path):
                            os.unlink(path)
                        else:
                            shutil.rmtree(path)
                    except Exception:
                        pass  # ignore locked files
            
            # Re-create subfolder
            os.makedirs(full, exist_ok=True)

    # ------------------------------------------------------------
    #  Login
    # ------------------------------------------------------------

    def login(self, username, password):
        print("üîê Logging in...")
        session = requests.Session()

        login_payload = {
            "username": username,
            "password": password,
            "useRememberMe": False
        }

        subdomain = "beta" if self.is_beta else "www"
        login_res = session.post(
            GAME_LOGIN_URL.format(subdomain=subdomain),
            headers=self.default_headers(),
            json=login_payload
        )
        login_res.raise_for_status()
        login_data = login_res.json()

        # Follow redirect to get client version
        redirect_res = session.get(login_data["redirectUrl"])
        redirect_res.raise_for_status()

        m = re.search(r'const\s+clientVersion\s*=\s*"([^"]+)"', redirect_res.text)
        if not m:
            raise Exception("Client version not found.")

        client_version = m.group(1)
        print(f"üìå Client version: {client_version}")

        # Establish session
        play_payload = {
            "createDeviceToken": False,
            "meta": {
                "clientVersion": client_version,
                "device": "browser",
                "deviceHardware": "browser",
                "deviceManufacturer": "none",
                "deviceName": "browser",
                "locale": "en_US",
                "networkType": "wlan",
                "operatingSystemName": "browser",
                "operatingSystemVersion": "1",
                "userAgent": "hoh-local-analyzer"
            },
            "network": "BROWSER_SESSION",
            "token": "",
            "worldId": None
        }

        subdomain2 = "zz0" if self.is_beta else "un0"

        play_res = session.post(
            ACCOUNT_PLAY_URL.format(subdomain=subdomain2),
            headers=self.default_headers(),
            json=play_payload
        )
        play_res.raise_for_status()
        self.session_data = play_res.json()
        self.session_data["clientVersion"] = client_version

        print("‚úÖ Login successful!")

    # ------------------------------------------------------------
    #  Fetch Startup Data
    # ------------------------------------------------------------

    def fetch_startup(self):
        print("\nüì• Fetching startup.json...")

        url = STARTUP_API_URL.format(world_id=self.world_id)

        # PROTOBUF version (binary)
        bin_res = requests.post(url, headers=self.api_headers(PROTOBUF_CONTENT_TYPE))
        bin_res.raise_for_status()
        startup_bin = bin_res.content

        # JSON version
        json_res = requests.post(url, headers=self.api_headers(JSON_CONTENT_TYPE))
        json_res.raise_for_status()
        startup_json_text = json_res.text

        # Save both
        self._save_file("raw/startup.bin", startup_bin, binary=True)
        self._save_file("raw/startup.json", startup_json_text)

        # Parse JSON
        self.startup = json.loads(startup_json_text)
        if "rootContext" in self.startup and "messages" in self.startup["rootContext"]:
            self.messages = self.startup["rootContext"]["messages"]
        else:
            raise Exception("Startup JSON missing rootContext.messages")

        print("‚úÖ Startup data loaded!")

    # ------------------------------------------------------------
    #  Fetch Wakeup Data
    # ------------------------------------------------------------

    def fetch_wakeup(self):
        """
        Fetches the protobuf WAKEUP response.
        This contains AllianceMembersResponse and many server-side internal states.
        """
        print("\nüì° Fetching wakeup data...")

        # Binary protobuf version
        url = f"https://{self.world_id}.heroesofhistorygame.com/game/wakeup"
        bin_res = requests.post(url, headers=self.api_headers(PROTOBUF_CONTENT_TYPE))
        bin_res.raise_for_status()

        wakeup_bin = bin_res.content
        self._save_file("raw/wakeup.bin", wakeup_bin, binary=True)

        # Base64-encoded version (optional)
        self.wakeup_base64 = base64.b64encode(wakeup_bin).decode("utf-8")

        # JSON version of wakeup (same trick as startup)
        json_res = requests.post(url, headers=self.api_headers(JSON_CONTENT_TYPE))
        json_res.raise_for_status()

        wakeup_json_text = json_res.text
        self._save_file("raw/wakeup.json", wakeup_json_text)

        self.wakeup_json = json.loads(wakeup_json_text)

        # Store messages
        if "rootContext" in self.wakeup_json and "messages" in self.wakeup_json["rootContext"]:
            self.wakeup_messages = self.wakeup_json["rootContext"]["messages"]
        else:
            self.wakeup_messages = []

        print("‚úÖ Wakeup data loaded!")

    # ------------------------------------------------------------
    #  Internal File Save Helper
    # ------------------------------------------------------------

    def _save_file(self, relative_path, data, binary=False):
        full_path = os.path.join(self.data_dir, relative_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)

        if binary:
            with open(full_path, "wb") as f:
                f.write(data)
        else:
            with open(full_path, "w", encoding="utf-8") as f:
                if isinstance(data, str):
                    f.write(data)
                else:
                    f.write(json.dumps(data, indent=2, ensure_ascii=False))

    # ============================================================
    #  SECTION 2: MESSAGE CLASSIFIER
    # ============================================================

    def classify_startup_messages(self):
        """
        Identify all DTO message types inside startup.json rootContext.messages
        and store raw data for later processing.
        """

        # Raw storages
        self.raw_playerdto = None
        self.raw_heropush = None
        self.raw_equipment_lists = []
        self.raw_relic_lists = []
        self.raw_cities = []
        self.raw_alliance_members = None
        self.raw_alliance_cities = []

        print("\nüîç Classifying startup messages...")

        for msg in self.messages:
            dto_type = msg.get("@type", "")

            # ------------------------------------------
            # PlayerDTO ‚Üí This is YOUR PLAYER PROFILE
            # ------------------------------------------
            if dto_type.endswith("PlayerDTO"):
                # Only store player whose id matches your session account
                self.raw_playerdto = msg
                continue

            # ------------------------------------------
            # HeroPush ‚Üí ALL HEROES + ALL DECKS
            # ------------------------------------------
            if dto_type.endswith("HeroPush"):
                self.raw_heropush = msg
                continue

            # ------------------------------------------
            # AllEquipmentUnitDataDTO ‚Üí equipment
            # ------------------------------------------
            if dto_type.endswith("AllEquipmentUnitDataDTO"):
                # May appear multiple times
                if "allEquipment" in msg:
                    self.raw_equipment_lists.append(msg["allEquipment"])
                continue

            # ------------------------------------------
            # RelicUnitDataDTO ‚Üí relics
            # ------------------------------------------
            if dto_type.endswith("RelicUnitDataDTO"):
                # Some relics may not contain hero reference ‚Üí we attach later
                self.raw_relic_lists.append(msg)
                continue

            # ------------------------------------------
            # CityDTO ‚Üí player's cities
            # ------------------------------------------
            if dto_type.endswith("CityDTO"):
                self.raw_cities.append(msg)
                continue

            # ------------------------------------------------------------
            # Process WAKEUP messages (contains alliance, ranking, etc.)
            # ------------------------------------------------------------
            for msg in getattr(self, "wakeup_messages", []):
                dto_type = msg.get("@type", "")

                if dto_type.endswith("AllianceMembersResponse"):
                    self.raw_alliance_members = msg
                    continue

                if dto_type.endswith("AllianceCityDTO"):
                    self.raw_alliance_cities.append(msg)
                    continue

        print("‚úÖ Message classification complete!")

    # ============================================================
    #  SECTION 2b: Build Master Tables (Patched)
    # ============================================================

    def build_master_tables(self):
        """
        Convert classified raw data into structured models:
          - Player info
          - Heroes (from HeroPush.unlocked)
          - Decks (from HeroPush.deck)
          - Equipment (AllEquipmentUnitDataDTO)
          - Relics (RelicUnitDataDTO)
          - Cities (from PlayerDTO.unlockedCities)  <-- FIXED
          - Alliance members (AllianceMembersResponse)
          - Alliance cities stored separately, not mixed with user cities
        """

        print("\nüß± Building master data tables...")

        # ------------------------------------------------------------
        # 1. Player Profile
        # ------------------------------------------------------------
        if self.raw_playerdto:
            self.player_info = {
                "id": self.raw_playerdto.get("id"),
                "displayName": self.raw_playerdto.get("displayName"),
                "username": self.raw_playerdto.get("username"),
                "allianceId": self.raw_playerdto.get("allianceId"),
            }
        else:
            self.player_info = {
                "id": None,
                "displayName": None,
                "username": None,
                "allianceId": None,
            }

        # ------------------------------------------------------------
        # 2. Heroes (from HeroPush.unlocked)
        # ------------------------------------------------------------
        if not self.raw_heropush:
            raise Exception("No HeroPush message found! Cannot build hero list.")

        self.heroes = []
        unlocked = self.raw_heropush.get("unlocked", [])

        for h in unlocked:
            hero_id = h.get("heroDefinitionId")

            self.heroes.append({
                "heroDefinitionId": hero_id,
                "name": hero_id.replace("hero.", "") if hero_id else None,
                "level": h.get("level"),
                "ascensionLevel": h.get("ascensionLevel"),
                "abilityLevel": h.get("abilityLevel"),
                "awakeningLevel": h.get("awakeningLevel"),
                "abilityMasteryPoints": h.get("abilityMasteryPoints"),
                "unlockedAt": h.get("unlockedAt")
            })

        hero_set = {h["heroDefinitionId"] for h in self.heroes}

        # ------------------------------------------------------------
        # 3. Decks (from HeroPush.deck)
        # ------------------------------------------------------------
        self.decks = []
        deck_list = self.raw_heropush.get("deck", [])

        for d in deck_list:
            self.decks.append({
                "definitionId": d.get("definitionId"),
                "heroes": [hid.replace("hero.", "") for hid in d.get("heroDefinitionId", [])]
            })

        # ------------------------------------------------------------
        # 4. Equipment (from AllEquipmentUnitDataDTO)
        # ------------------------------------------------------------
        self.equipment = {}

        for equip_group in self.raw_equipment_lists:
            for eq in equip_group:
                hero_def = eq.get("equippedOnHeroDefinitionId")
                if hero_def and hero_def in hero_set:
                    hero_name = hero_def.replace("hero.", "")
                    if hero_name not in self.equipment:
                        self.equipment[hero_name] = []

                    self.equipment[hero_name].append({
                        "id": eq.get("id"),
                        "slot": eq.get("equipmentSlotTypeDefinitionId"),
                        "set": eq.get("equipmentSetDefinitionId"),
                        "rarity": eq.get("equipmentRarityDefinitionId"),
                        "level": eq.get("level"),
                        "mainAttribute": eq.get("mainAttribute"),
                        "subAttributes": eq.get("subAttributes", [])
                    })

        # ------------------------------------------------------------
        # 5. Relics (RelicUnitDataDTO)
        # ------------------------------------------------------------
        self.relics = {}

        for relic_entry in self.raw_relic_lists:
            relic_def = relic_entry.get("relicDefinitionId")
            level = relic_entry.get("level")
            age = relic_entry.get("ageDefinitionId")

            hero_def = None
            if "supportingUnit" in relic_entry:
                hero_def = relic_entry["supportingUnit"].get("definitionId")

            # Only attach relics belonging to heroes you own
            if hero_def and hero_def in hero_set:
                hero_name = hero_def.replace("hero.", "")
                if hero_name not in self.relics:
                    self.relics[hero_name] = []
                self.relics[hero_name].append({
                    "relicDefinitionId": relic_def,
                    "level": level,
                    "age": age
                })

        # ------------------------------------------------------------
        # 6. USER CITIES (from PlayerDTO.unlockedCities)  <-- FIXED
        # ------------------------------------------------------------
        self.cities = []

        unlocked_cities = []
        if self.raw_playerdto:
            unlocked_cities = self.raw_playerdto.get("unlockedCities", [])

        for c in unlocked_cities:
            self.cities.append({
                "id": c.get("id"),
                "definitionId": c.get("definitionId"),
                "placedBuildingAmounts": c.get("placedBuildingAmounts", {}),
                "buildingLimits": c.get("buildingLimits", {})
            })

        # ------------------------------------------------------------
        # 7. Alliance Members (correct parsing)
        # ------------------------------------------------------------
        self.alliance_members = []

        if self.raw_alliance_members:
            for m in self.raw_alliance_members.get("members", []):
                player = m.get("player", {})

                self.alliance_members.append({
                    "id": player.get("id"),
                    "name": player.get("name"),
                    "age": player.get("age"),
                    "role": m.get("role_details", {}).get("role"),
                    "rankingPoints": m.get("ranking_points"),
                    "secondsSinceOnline": m.get("seconds_since_last_online"),
                    "joinedAt": m.get("joined_at")
                })

            # Also store alliance ID properly
            self.player_info["allianceId"] = self.raw_alliance_members.get("alliance_id")
        else:
            self.player_info["allianceId"] = None

        # ------------------------------------------------------------
        # 8. Alliance Cities (kept separate, not mixed with user cities)
        # ------------------------------------------------------------
        self.alliance_cities = []
        for ac in self.raw_alliance_cities:
            self.alliance_cities.append({
                "id": ac.get("id"),
                "ownerId": ac.get("playerId"),
                "definitionId": ac.get("definitionId")
            })

        print("‚úÖ Master tables built!  (Cities fixed)")
        
    # ============================================================
    #  SECTION 3: CSV EXPORTS
    # ============================================================

    def export_to_csv_all(self):
        """
        Export all structured data to CSV files.
        Files:
          - heroes.csv
          - equipment.csv
          - relics.csv
          - decks.csv
          - cities.csv
          - alliance_members.csv
        """
        csv_dir = os.path.join(self.data_dir, "csv_exports")
        os.makedirs(csv_dir, exist_ok=True)

        self._export_heroes_csv(csv_dir)
        self._export_equipment_csv(csv_dir)
        self._export_relics_csv(csv_dir)
        self._export_decks_csv(csv_dir)
        self._export_cities_csv(csv_dir)
        self._export_alliance_members_csv(csv_dir)

        print(f"üìä CSV export complete! Saved to: {csv_dir}")

    # ------------------------------------------------------------
    # HEROES CSV
    # ------------------------------------------------------------

    def _export_heroes_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "heroes.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow([
                "heroDefinitionId", "name", "level", "ascensionLevel",
                "awakeningLevel", "abilityLevel", "abilityMasteryPoints", "unlockedAt"
            ])
            for h in self.heroes:
                writer.writerow([
                    h.get("heroDefinitionId"),
                    self.translate_hero(h.get("name")),
                    h.get("level"),
                    h.get("ascensionLevel"),
                    h.get("awakeningLevel"),
                    h.get("abilityLevel"),
                    h.get("abilityMasteryPoints"),
                    h.get("unlockedAt"),
                ])

    # ------------------------------------------------------------
    # EQUIPMENT CSV
    # ------------------------------------------------------------

    def _export_equipment_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "equipment.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)

            writer.writerow([
                "heroName", "equipmentId", "slot", "set", "rarity", "level",
                "mainAttribute_stat", "mainAttribute_value",
                "subAttributes"  # stored as JSON string for convenience
            ])

            for hero_name, items in self.equipment.items():
                for eq in items:
                    main_attr = eq.get("mainAttribute", {})
                    stat_boost = main_attr.get("statBoost", {})

                    main_stat = stat_boost.get("unitStatDefinitionId")
                    main_value = stat_boost.get("value")

                    # Subattributes as JSON
                    sub_json = json.dumps(eq.get("subAttributes", []), ensure_ascii=False)

                    writer.writerow([
                        self.translate_hero(hero_name),
                        eq.get("id"),
                        self.translate_equipment_slot(eq.get("slot")),
                        self._clean_id_label(eq.get("set")),
                        self.translate_equipment_rarity(eq.get("rarity")),
                        eq.get("level"),
                        self.translate_stat(main_stat),
                        main_value,
                        sub_json
                    ])

    # ------------------------------------------------------------
    # RELICS CSV
    # ------------------------------------------------------------

    def _export_relics_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "relics.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["heroName", "relicDefinitionId", "level", "age"])

            for hero_name, relic_list in self.relics.items():
                for r in relic_list:
                    writer.writerow([
                        self.translate_hero(hero_name),
                        self.translate_relic(r.get("relicDefinitionId")),
                        r.get("level"),
                        self._clean_id_label(r.get("age"))
                    ])

    # ------------------------------------------------------------
    # DECKS CSV
    # ------------------------------------------------------------

    def _export_decks_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "decks.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["definitionId", "heroes"])

            for d in self.decks:
                writer.writerow([
                    self._clean_id_label(d.get("definitionId")),
                    ", ".join(self.translate_hero(h) for h in d.get("heroes", []))
                ])

    # ------------------------------------------------------------
    # CITIES CSV
    # ------------------------------------------------------------

    def _export_cities_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "cities.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)

            writer.writerow(["id", "definitionId", "level", "placedBuildingsJSON"])

            for c in self.cities:
                placed_json = json.dumps(
                    c.get("placedBuildingAmounts", {}),
                    ensure_ascii=False
                )
                writer.writerow([
                    c.get("id"),
                    self._clean_id_label(c.get("definitionId")),
                    c.get("level"),
                    placed_json
                ])

    # ------------------------------------------------------------
    # ALLIANCE MEMBERS CSV
    # ------------------------------------------------------------

    def _export_alliance_members_csv(self, csv_dir):
        import csv

        path = os.path.join(csv_dir, "alliance_members.csv")
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)

            writer.writerow(["id", "name", "level", "power", "age"])

            for m in self.alliance_members:
                writer.writerow([
                    m.get("id"),
                    self._clean_id_label(m.get("name")),
                    m.get("role"),
                    m.get("rankingPoints"),
                    m.get("secondsSinceOnline"),
                    self._clean_id_label(m.get("age"))
                ])                
    # ============================================================
    #  SECTION 4: FULL DASHBOARD HTML
    # ============================================================

    def create_summary_dashboard(self):
        """
        Generate a full HTML dashboard containing:
          - Hero list
          - Equipment per hero
          - Relics per hero
          - Deck/team lists
          - Cities
          - Alliance members
          - Summary metrics
        """

        print("\nüåê Generating full dashboard...")

        # ------------------------------------------------------------
        # Summary Calculations
        # ------------------------------------------------------------

        total_heroes = len(self.heroes)
        total_equipment_items = sum(len(eqs) for eqs in self.equipment.values())
        total_relics = sum(len(r) for r in self.relics.values())
        total_cities = len(self.cities)
        alliance_count = len(self.alliance_members)

        # Current Timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Player Name
        player_name = self.player_info.get("displayName") or self.player_info.get("username") or "Unknown"
        alliance_id = self.player_info.get("allianceId")

        # ------------------------------------------------------------
        # Build Hero Table HTML
        # ------------------------------------------------------------
        hero_rows = []
        for h in sorted(self.heroes, key=lambda x: x["level"], reverse=True):
            hero_rows.append(f"""
                <tr>
                    <td>{self.translate_hero(h['name'])}</td>
                    <td>{h['level']}</td>
                    <td>{h.get('ascensionLevel', '')}</td>
                    <td>{h.get('awakeningLevel', '')}</td>
                    <td>{h.get('abilityLevel', '')}</td>
                    <td>{h.get('abilityMasteryPoints', '')}</td>
                </tr>
            """)

        hero_table_html = "".join(hero_rows)

        # ------------------------------------------------------------
        # Build Equipment HTML
        # ------------------------------------------------------------
        equipment_sections = []

        for hero_name, eq_list in self.equipment.items():
            rows = []
            for eq in eq_list:
                main_attr = eq.get("mainAttribute", {})
                statboost = main_attr.get("statBoost", {})
                main_stat = statboost.get("unitStatDefinitionId")
                main_value = statboost.get("value")

                # Subattributes
                sub_list = []
                for s in eq.get("subAttributes", []):
                    stat = s.get("unitStatAttributeDefinitionId")
                    unlocked_at = s.get("unlockedAtLevel")
                    rolled = s.get("rolledValue")
                    sub_list.append(f"{self.translate_stat(stat)} (unlock {unlocked_at}, rolled {rolled})")

                sub_text = "<br>".join(sub_list)

                rows.append(f"""
                    <tr>
                        <td>{self.translate_equipment_slot(eq.get("slot"))}</td>
                        <td>{self._clean_id_label(eq.get("set"))}</td>
                        <td>{self.translate_equipment_rarity(eq.get("rarity"))}</td>
                        <td>{eq.get("level")}</td>
                        <td>{self.translate_stat(main_stat)}</td>
                        <td>{main_value}</td>
                        <td>{sub_text}</td>
                    </tr>
                """)

            table_rows = "".join(rows)

            equipment_sections.append(f"""
                <h3>{self.translate_hero(hero_name)}</h3>
                <table>
                    <tr>
                        <th>Slot</th>
                        <th>Set</th>
                        <th>Rarity</th>
                        <th>Level</th>
                        <th>Main Stat</th>
                        <th>Value</th>
                        <th>Subattributes</th>
                    </tr>
                    {table_rows}
                </table>
            """)

        equipment_html = "".join(equipment_sections)

        # ------------------------------------------------------------
        # Relics per hero
        # ------------------------------------------------------------
        relic_sections = []
        for hero_name, relic_list in self.relics.items():
            rows = []
            for r in relic_list:
                rows.append(f"""
                    <tr>
                        <td>{self.translate_relic(r.get("relicDefinitionId"))}</td>
                        <td>{r.get("level")}</td>
                        <td>{self._clean_id_label(r.get("age"))}</td>
                    </tr>
                """)
            relic_rows = "".join(rows)

            relic_sections.append(f"""
                <h3>{self.translate_hero(hero_name)}</h3>
                <table>
                    <tr>
                        <th>Relic</th>
                        <th>Level</th>
                        <th>Age</th>
                    </tr>
                    {relic_rows}
                </table>
            """)

        relic_html = "".join(relic_sections)

        # ------------------------------------------------------------
        # Decks
        # ------------------------------------------------------------
        deck_rows = []
        for d in self.decks:
            heroes_list = ", ".join(self.translate_hero(hero) for hero in d.get("heroes", []))
            deck_rows.append(f"""
                <tr>
                    <td>{self._clean_id_label(d.get("definitionId"))}</td>
                    <td>{heroes_list}</td>
                </tr>
            """)

        decks_html = "".join(deck_rows)

        # ------------------------------------------------------------
        # Cities
        # ------------------------------------------------------------
        city_rows = []
        for c in self.cities:

            # ----------- Grouped buildings (Category -> Size -> Levels) -----------
            placed = c.get("placedBuildingAmounts", {})
            groups = self._group_buildings(placed)

            ghtml = ""
            for category, sizes in groups.items():
                total = sum(s["count"] for s in sizes.values())
                ghtml += f"<h4>{category} ‚Äî Total: {total}</h4>\n<ul>"

                for size, info in sizes.items():
                    level_list = ", ".join(str(l) for l in info["levels"])
                    ghtml += f"<li>{size} ‚Äî {info['count']} (levels: {level_list})</li>"

                ghtml += "</ul>"

            buildings_html = ghtml if ghtml else "None"

            city_rows.append(f"""
                <tr>
                    <td>{c.get("id")}</td>
                    <td>{self._clean_id_label(c.get("definitionId"))}</td>
                    <td>{buildings_html}</td>
                </tr>
            """)

        cities_html = "".join(city_rows)

        # ------------------------------------------------------------
        # Alliance Members
        # ------------------------------------------------------------
        alliance_rows = []
        for m in self.alliance_members:
            alliance_rows.append(f"""
                <tr>
                    <td>{m.get("id")}</td>
                    <td>{self._clean_id_label(m.get("name"))}</td>
                    <td>{self._clean_id_label(m.get("role"))}</td>
                    <td>{m.get("rankingPoints")}</td>
                    <td>{m.get("secondsSinceOnline")}</td>
                    <td>{self._clean_id_label(m.get("age"))}</td>
                </tr>
            """)

        alliance_html = "".join(alliance_rows)

        # ------------------------------------------------------------
        # HTML TEMPLATE  (all braces escaped)
        # ------------------------------------------------------------

        html = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Heroes of History - Full Dashboard</title>
    <style>
        body {{ font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 20px; }}
        h1 {{ color: #2c3e50; }}
        h2 {{ margin-top: 40px; color: #34495e; }}
        h3 {{ margin-top: 25px; color: #7f8c8d; }}
        table {{ width: 100%; border-collapse: collapse; margin-bottom: 30px; }}
        th {{ background-color: #2c3e50; color: white; padding: 8px; text-align: left; }}
        td {{ background-color: #ffffff; padding: 8px; border-bottom: 1px solid #ddd; }}
        .summary-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }}
        .summary-box {{
            background: #3498db;
            color: white;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }}
        .label {{ font-size: 0.8em; opacity: 0.9; }}
        .value {{ font-size: 1.6em; font-weight: bold; }}
    </style>
</head>

<body>
    <h1>Heroes of History - Full Dashboard</h1>
    <p>Player: {player_name} | Alliance ID: {alliance_id} | Generated: {timestamp}</p>

    <div class="summary-grid">
        <div class="summary-box"><div class="value">{total_heroes}</div><div class="label">Heroes</div></div>
        <div class="summary-box"><div class="value">{total_equipment_items}</div><div class="label">Equipment Items</div></div>
        <div class="summary-box"><div class="value">{total_relics}</div><div class="label">Relics</div></div>
        <div class="summary-box"><div class="value">{total_cities}</div><div class="label">Cities</div></div>
        <div class="summary-box"><div class="value">{alliance_count}</div><div class="label">Alliance Members</div></div>
    </div>

    <h2>Hero List</h2>
    <table>
        <tr>
            <th>Hero</th>
            <th>Level</th>
            <th>Ascension</th>
            <th>Awakening</th>
            <th>Ability Level</th>
            <th>Mastery</th>
        </tr>
        {hero_table_html}
    </table>

    <h2>Equipment by Hero</h2>
    {equipment_html}

    <h2>Relics by Hero</h2>
    {relic_html}

    <h2>Hero Decks (Teams)</h2>
    <table>
        <tr>
            <th>Deck</th>
            <th>Heroes</th>
        </tr>
        {decks_html}
    </table>

    <h2>Cities</h2>
    <table>
        <tr>
            <th>ID</th>
            <th>DefinitionId</th>
            <th>Placed Buildings</th>
        </tr>
        {cities_html}
    </table>

    <h2>Alliance Members</h2>
    <table>
        <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Role</th>
            <th>Ranking Points</th>
            <th>Seconds Offline</th>
            <th>Age</th>
        </tr>
        {alliance_html}
    </table>

</body>
</html>
        """

        # ------------------------------------------------------------
        # Save HTML
        # ------------------------------------------------------------

        out_path = os.path.join(self.data_dir, "analysis", "dashboard.html")
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(html)

        print(f"üåê Dashboard created: {out_path}")
        return out_path
    
    # ============================================================
    #  SECTION 5: JSON ANALYSIS EXPORT + PARSED DATA SAVE
    # ============================================================

    def export_analysis_json(self):
        """
        Produces a complete analysis JSON structure containing:
            - player info
            - heroes
            - equipment
            - relics
            - decks
            - cities
            - alliance members
            - alliance cities
            - timestamp
        Saves to: analysis/player_analysis.json
        """

        print("\nüìù Exporting analysis summary JSON...")

        analysis = {
            "timestamp": datetime.now().isoformat(),
            "player": self.player_info,
            "heroes": self.heroes,
            "equipment": self.equipment,
            "relics": self.relics,
            "decks": self.decks,
            "cities": self.cities,
            "allianceMembers": self.alliance_members,
            "allianceCities": self.alliance_cities,
        }

        path = os.path.join(self.data_dir, "analysis", "player_analysis.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)

        with open(path, "w", encoding="utf-8") as f:
            json.dump(analysis, f, indent=2, ensure_ascii=False)

        print(f"üìÑ Analysis JSON written ‚Üí {path}")
        return analysis

    # ------------------------------------------------------------
    # SAVE PARSED RAW DATA FOR DEBUGGING
    # ------------------------------------------------------------

    def save_parsed_data(self):
        """
        Save all parsed raw-message-derived data structures into parsed/ directory.
        This is useful for understanding startup.json structures and debugging.
        """

        print("\nüíæ Saving parsed data structures...")

        base = os.path.join(self.data_dir, "parsed")
        os.makedirs(base, exist_ok=True)

        raw_bundle = {
            "playerDTO": self.raw_playerdto,
            "heroPush": self.raw_heropush,
            "equipment_rawLists": self.raw_equipment_lists,
            "relic_rawLists": self.raw_relic_lists,
            "cities_raw": self.raw_cities,
            "allianceMembers_raw": self.raw_alliance_members,
            "allianceCities_raw": self.raw_alliance_cities
        }
        
        raw_bundle["wakeup_raw"] = getattr(self, "wakeup_json", {})

        # Save a single bundle file containing everything
        with open(os.path.join(base, "parsed_raw_bundle.json"), "w", encoding="utf-8") as f:
            json.dump(raw_bundle, f, indent=2, ensure_ascii=False)

        # Also save master tables for debugging
        master_bundle = {
            "player": self.player_info,
            "heroes": self.heroes,
            "decks": self.decks,
            "equipment": self.equipment,
            "relics": self.relics,
            "cities": self.cities,
            "allianceMembers": self.alliance_members,
            "allianceCities": self.alliance_cities
        }

        with open(os.path.join(base, "parsed_master_bundle.json"), "w", encoding="utf-8") as f:
            json.dump(master_bundle, f, indent=2, ensure_ascii=False)

        print("üíæ Parsed data saved.")
        
# ============================================================
#  SECTION 6 ‚Äî MAIN RUNNER
# ============================================================

def main():
    parser = argparse.ArgumentParser(description="Heroes of History - Local Startup Analyzer")
    parser.add_argument("--world", default="un1", help="World to connect to (un1, zz1, etc.)")
    parser.add_argument("--data-dir", default="hoh_local_data", help="Directory for output files")
    parser.add_argument("--skip-download", action="store_true", help="Use existing startup.json without logging in")

    args = parser.parse_args()

    print("üéÆ Heroes of History - Local Data Analyzer")
    print("=" * 60)
    print(f"World: {args.world}")
    print(f"Output directory: {args.data_dir}")
    print()

    analyzer = HoHLocalAnalyzer(world_id=args.world, data_dir=args.data_dir)
    analyzer.setup_directories()
    analyzer.load_metadata()

    try:
        # ------------------------------------------------------------
        # LOGIN + FETCH STARTUP.JSON
        # ------------------------------------------------------------
        if not args.skip_download:
            username = input("Username: ")
            password = getpass("Password: ")

            analyzer.login(username, password)
            analyzer.fetch_startup()
            analyzer.fetch_wakeup()
        else:
            print("üìÇ Using existing startup.json...")
            startup_path = os.path.join(args.data_dir, "raw", "startup.json")
            if not os.path.exists(startup_path):
                raise Exception("startup.json not found ‚Äî cannot skip download.")

            with open(startup_path, "r", encoding="utf-8") as f:
                analyzer.startup = json.load(f)

            analyzer.messages = analyzer.startup.get("rootContext", {}).get("messages", [])

        # ------------------------------------------------------------
        # PARSE STARTUP MESSAGES
        # ------------------------------------------------------------
        analyzer.classify_startup_messages()
        analyzer.build_master_tables()

        # Save raw parsed structures for debugging
        analyzer.save_parsed_data()

        # ------------------------------------------------------------
        # EXPORTS ‚Äî JSON, CSV, DASHBOARD
        # ------------------------------------------------------------
        analysis_json = analyzer.export_analysis_json()
        analyzer.export_to_csv_all()
        dashboard_path = analyzer.create_summary_dashboard()

        # ------------------------------------------------------------
        # FINAL SUMMARY
        # ------------------------------------------------------------
        print("\n" + "=" * 60)
        print("üìä ANALYSIS COMPLETE")
        print("=" * 60)
        print(f"Player: {analysis_json['player'].get('displayName', 'Unknown')}")
        print(f"Heroes: {len(analysis_json['heroes'])}")
        print(f"Equipment items: {sum(len(v) for v in analysis_json['equipment'].values())}")
        print(f"Relics: {sum(len(v) for v in analysis_json['relics'].values())}")
        print(f"Cities: {len(analysis_json['cities'])}")
        print(f"Alliance members: {len(analysis_json['allianceMembers'])}")
        print()
        print(f"üìÅ Data directory: {os.path.abspath(args.data_dir)}")
        print(f"üìÑ Analysis JSON: {os.path.join(args.data_dir, 'analysis/player_analysis.json')}")
        print(f"üåê Dashboard: {dashboard_path}")
        print(f"üìä CSV Exports: {os.path.join(args.data_dir, 'csv_exports')}")
        print()

        return 0

    except Exception as e:
        print("\n‚ùå Error:", str(e))
        import traceback
        traceback.print_exc()
        return 1


# ------------------------------------------------------------
# Script Entry Point
# ------------------------------------------------------------
if __name__ == "__main__":
    exit(main())